# MySQL 是如何实现事务的

事务是指作为单个逻辑工作单元执行的一系列操作，具有ACID特性：

- **原子性(Atomicity)**：事务中的所有操作要么全部完成，要么全部不完成
- **一致性(Consistency)**：事务执行前后数据库都保持一致性状态
- **隔离性(Isolation)**：并发事务之间互不干扰
- **持久性(Durability)**：事务完成后对数据的修改是永久性的

所以我们回答的时候从这几个方面进行回答。

1. 原子性

实现方式为 Undo Log（回滚日志），事务中的每一步操作，都会记录到 Undo Log 中，也就是会保存一份修改前的数据副本。此时如果事务失败或者主动回滚，就可以根据日志恢复到事务前的状态。

2. 持久性

实现方式为 Redo Log（重做日志）和 WAL 原则，在事务提交前，所有的修改都会先写入到 Redo Log 中，然后再对数据进行修改，此时就算是系统崩溃也可以在重启后读取 Redo Log，重新执行这些操作，将数据恢复到崩溃前的状态。

3. 隔离性

实现方式为 MVCC 和锁机制

MVCC 简单来说就是通过保存数据的多个版本，让读写事务互相不阻塞，MVCC 有隐藏的版本链和 ReadView，根据版本可见性规则

* `DB_TRX_ID` < `min_trx_id` 最近修改当前数据行的事务 id < 活跃事务中的最小 id → 说明这行数据是已提交的旧数据（可见）
* `DB_TRX_ID` ≥ `max_trx_id` 最近修改当前数据行的事务 id >= 系统将分配的下一个事务的 id → 未来事务修改的数据（不可见）
* `min_trx_id` ≤ `DB_TRX_ID` < `max_trx_id` 如果DB_TRX_ID`在`m_ids 中，也就是该数据行处于一个未提交事务修改的状态，那就是不可见，反之则可见。

锁机制

- **共享锁（S锁）**：读锁，允许其他事务并发读，但阻塞写。
- **排他锁（X锁）**：写锁，阻塞其他事务的读写。
- **间隙锁（Gap Lock）**：在 RR 级别下防止幻读，锁定索引记录间的间隙。

4. 一致性

一致性通过 **原子性 + 隔离性 + 持久性** 共同保障。
